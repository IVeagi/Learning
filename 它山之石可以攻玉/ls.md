
# 一、相关说明

1、首要问题
面试中最首要的问题，就是如何让面试官对你留下好印象。即使你什么都不会，面试官如果对你印象好也能通过。否则即使面试很顺利，但面试官对你印象不好，眼缘不好的话，也无法通过。

反例如下
● 不懂装懂、明明不会还在那里瞎说、瞎吹牛
● 态度不友善、不谦卑
2、考的是什么
考的是你分析问题的能力，分析问题的步骤，而不是想要你说出答案，相反注重的是你分析问题的过程。这和读书、跑步都是同样的道理，任何事情重要的其实不是结果，而是你做这个事情的过程。
3、做题方法
(1) 做题要认真，看清参数是字符串还是数组
(2) 不要看见就说不会，要学会分析问题【对问题本质分析清楚、从组成、使用、功能上入手】
(3) 对于算法类型的题目，把“暴力解法”、“打表”，“二分查找”、“回溯”、“栈”、“优先队列”、“排序”、“堆”、“快慢指针”、“动态规划”、“贪心”、“二进制位运算”等等都作为解题的工具，每遇到一个题目就依次尝试，直到此工具可以解出问题
4、自我介绍
重点是引起面试官的好感，让他对你产生兴趣

# 二、网络

## 1、TCP部分

* (1) TCP三次握手
当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的

当server端发送SYN报文时，可能出现网络等原因导致客户端无法接收，所以必须有一种机制让服务端知道SYN报文已经被客户端正常接收了【三次握手的原因】
![image](https://user-images.githubusercontent.com/30583971/157209187-dd4391bf-c4f6-4303-b54b-e7f52756fac0.png)

* (2) TCP四次挥手
关闭连接时，当Server端收到FIN报文时，因为此时可能还存在数据传送，所以Server端很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文告诉客户端已收到请求。然后服务端一直等到数据传送完全结束后，再次向客户端发送FIN报文

答 ：由于数据还有可能传送，服务端无法立即关闭连接，所以ACK和FIN报文无法同时发送，只能拆分为两次发送，所以比三次握手多了一次【四次挥手的原因】

* (3) TCP TIME_WAIT
① TCP连接是双向的，所以在关闭连接的时候，两个方向各自都需要关闭。
② 先发FIN包的一方执行的是主动关闭，后发送FIN包的一方执行的是被动关闭。
③ 主动关闭的一方会进入TIME_WAIT状态，并且在此状态停留2MSL时长。
④ 对于MSL，其指的是报文段的最大生存时间。如果报文段在网络中活动了MSL时间，还没有被接收，那么就会被丢弃。关于MSL的大小，RFC 793协议中给出的建议是2分钟，不过Linux中，通常是半分钟。

TIME_WAIT的产生条件：主动关闭方在发送四次挥手的最后一个ACK后会变为TIME_WAIT状态，持续时间为2MSL（Linux中一个MSL是30秒，是不可配置的）

TIME_WAIT持续两个MSL的作用（为什么要有time_wait）：可靠安全地关闭TCP连接。


* (4) SYN、FIN、ACK、MSL
SYN报文是用来同步的，FIN报文是用来结束的、ACK报文是用来应答的
MSL ：最大报文段生存时间
* (5) 如果已建立连接，但是客户端故障了怎么办
TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
* (6) 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？
为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？

答 ：因为ACK发送有可能丢失，当server端一直收不到Ack时，就会再次发送FIN报文，所以客户端需要尽可能等待Ack包被server正常接收
这个很像我写过的一个Go项目，不过场景是需要等待信号的发送，确保信号能被正常接收
* (7) Redis为什么会产生大量的time_wait
在Redis连接中（使用 php-redis也是同理），我们使用 QUIT、control + c 等任何关闭连接的命令，Redis 服务器都是主动关闭方，而在 TCP 连接中，主动关闭方会产生 time_wait 状态且持续 2MSL ，在此期间 socket 不会关闭，且会继续占用端口。

所以在 Redis 高并发场景下，Redis 服务器会产生大量的 time_wait ，占用系统的 socket 资源，如果过多，会导致无法建立 Redis 连接的情况，进而出现：Redis went away 错误
* (8) TCP拥塞控制，具体过程是怎么样的？
拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；

常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。

指数增长：先从小数据包开始发送，试探网络拥塞程度，指数增加数据包大小
加法增大：拥塞避免
乘法减少：达到窗口最大值时，开始乘法减小

* (9) TCP如何保证传输的可靠性？
三次握手 + 四次挥手 + 拥塞控制 + 流量控制 + 超时重发 + 滑动窗口控制
* (10) tcp和udp的报文结构了解么


* (11) UDP有拥塞控制吗？UDP丢包原因？如何解决？
没有拥塞控制，解决方法 ：控制发送包的频率和大小，把大包切割多个小包一点一点去发送

* (12) 握手时产生的序列号干什么用的
TCP是一种可靠的面向连接的数据流协议，TCP之所以可靠，是因为它保证了数据的传输有序，这是通过一个序列号和确认号来保证的。

确认号的作用：
通信双方采用确认号来对收到的数据进行确认，该确认号之前（不包括该确认号）的所有数据均已正确收到，希望下次接收序列号为该确认号的数据。
* (13) Close_wait状态是什么
服务器接收到客户端断开连接请求时会进入到CLOSE_WAIT状态，然后发送ACK包至客户端，等待数据传输完成后再发送FIN包
* (14) TCP的流量控制和接收窗口
TCP的接收窗口就是滑动窗口，就是服务器发送客户端确认报文中的窗口字段，这个字段会影响到客户端的发送速度。

流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。

接收方发送的确认报文中的窗口字段（接收窗口）可以用来控制发送方窗口大小，从而影响发送方的发送速率。 将窗口字段设置为0，则发送方不能发送数据。
* (15) 100Mbps的带宽三个人使用，每人50Mbps，tcp怎么保证速度的
TCP的流量控制和拥塞控制
* (16) 客户端和服务端都有哪些状态
客户端状态 ：CLOSED（关闭）、SYN-SENT（同步已发送）、ESTABLISHED（已建立连接）
服务端状态 ：CLOSED（关闭）、LISTEN（收听）、SYN-RCVD（同步已收到）、ESTABLISHED（已建立连接）
* (17) SYN攻击

* (18) TCP和UDP区别
* (19) http 与 tcp 的关系
* (20) tcp 可以建立多个连接吗？

## 2、HTTP部分

(1) HTTP和HTTPS的区别
● HTTP默认工作在80端口，HTTPS工作在443端口
● 都是应用层协议，都是要TCP传输
● HTTP明文传输，HTTPS加密传输
● HTTPS在应用层还会使用专门用于传输加密的SSL/TLS协议
(2) POST和GET的区别
GET是幂等的，而POST则不是幂等的
① 功能不同 ：GET是用来从服务器获取数据，POST是用来向服务器上传数据
② 量级不同 ：GET传输数据小，POST传输数据大，默认不限制
(3) HTTP Code
● 500 ：服务程序内部的错误，一般是源码级别的错误
● 501 ：服务器不支持当前的资源请求
● 502 ：服务器网关层面的错误，一般未进入到服务程序
● 503 ：过载请求
● 504 ：网关超时

(4) https实现原理
对称加密+非对称加密
(5) http版本问题
1.1 ：最早被广泛使用的版本，不支持TCP连接复用
2.0 ：支持多路复用（TCP连接复用）、分块传输、更多的请求方式（PUT、HEAD、DELETE等）
(6) http如何多路复用
使用请求头 Connection: keep-alive
(7) http各种头的作用
Cookie ：
User-Agent ：
Refer ：
accept ：
accept-encodeing ：
cache-control ：
(8) https握手过程

### 3、XSS和CSRF

XSS是代码注入问题，CSRF是HTTP问题。XSS是内容没有过滤导致浏览器将攻击者的输入当成代码执行。CSRF则是因为浏览器在发送HTTP请求时自动带上Cookie，而一般网站的SESSION都与Cookie关联，所以会恶意获取到用户的登录信息，用Token机制可以解决

### 4、长连接和短连接

HTTP是无状态的的短链接，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接

客户端发起并建立TCP连接 -> 客户端发送请求报文 -> 服务端接收报文 -> 服务端发送响应报文给前端，发送完之后立即调用socket.close方法 -> 客户端接收响应报文 -> 客户端最终会收到服务端断开TCP连接的信号 -> 客户端断开TCP连接，具体就是调用close方法

在客户端的请求中，如果有 keep-alive 请求头，则表示客户端希望服务端响应后不要立即关闭连接，而是在
Keep-Alive: timeout=20 20s超时之后，可以关闭

(1) 长连接
客户端和服务端在进行一次会话后，服务端并不立即断开TCP，而是会等待一段时间，直到时间超时（timeout），或者客户端主动关闭

(2) 短连接
客户端和Server进行一次会话后（客户端请求-服务端响应），服务端发送TCP断开请求，客户端响应断开

### 5、输入Url到页面显示的整个过程

解析域名的过程 ：浏览器查缓存 -> DNS解析域名 -> 获得目标服务器的IP
建立连接的过程 ：基于TCP三次握手建立连接
传输数据的过程 ：浏览器生成应用层数据包，调用OS内核，OS会在应用层数据包基础上添加源端口号和目标端口号等数据生成运输层数据包，再传递至网络层，网络层添加源IP和目标IP后发送至链路层，直至发送至目标主机，目标主机再拆解数据包

### 6、ping使用的协议

ping是用来探测服务器和服务器之间是否连通，主要检测的是网络是否互通，所以使用的主要是网络层的协议，所以是 ICMP 协议。如果我们要 ping www.baidu.com 首先就要先进行 DNS 域名解析获得 IP 地址。

ICMP协议。 ICMP 是 TCP/IP 模型中网络层的重要成员,与 IP 协议、ARP 协议、RARP 协议及 IGMP 协议共同构成 TCP/IP 模型中的网络层。
### 7、域名有多个IP时的域名解析问题
● 首先DNS会有自己的负载均衡算法，所以当有多个IP时，DNS解析服务会使用负载均衡算法返回其中的某一个IP
● 所以每次域名请求时DNS会根据负载均衡算法返回不同的ip地址。
### 8、域名解析NDS负载均衡的过程
### 9、TCP和UDP协议的区别
TCP提供可靠的网络通信
UDP提供不可靠的网络通信
### 10、如何保证消息不被窃取
发消息时，网络传输过程中（只说应用层）信息怎么保证不被窃取
### 11、http三次握手，如果第三次客户端发出的信息服务器没收到怎么办？
### 12、arp广播，会造成网络风暴，那应该怎么解决
### 13、路由器/交换机是哪一层
路由器工作在网络层
交换机工作在链路层
### 14、什么时候选择TCP/UDP
是否可以容忍网络数据包的丢失
### 15、网络层用来干嘛？传输层用来干嘛？
网络层用来找到目标主机，传输层用来找到主机上的目标应用

### 16、Socket部分

(1) bind和listen分别做什么
bind ：把socket绑定在一个IP地址和端口上
listen ：监听由指定socket的连接

(2) accept怎么建立新的连接
监听之后，接收一个即将来临的新的连接，如果连接建立成功，将返回一个新的 socket 句柄（你可以理解为子进程，通常父进程用来接收新的连接，子进程负责具体的通信）

(3) C语言编写服务器和客户端程序常用步骤

(4) 网络编程里backlog的作用

# 三、基础
## 1、线程/进程间通信方式
进程间通信 ：信号，共享内存，socket，文件，消息队列，管道，信号量

线程间通信 ：全局变量，静态变量
## 2、线程/进程区别
(1) 进程是CPU资源分配的基本单位，线程是CPU执行和调度的基本单位
(2) 线程间通信比进程间通信方便，开销比进程小
## 3、操作系统的设计总结
(1) 以多进程形式，允许多个任务同时运行

(2) 以多线程形式，允许单个任务分成不同的部分运行

(3) 提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源

## 4、阻塞和非阻塞区别
阻塞是指调用线程或者进程被操作系统挂起。非阻塞是指调用线程或者进程不会被操作系统挂起
## 5、同步和异步的区别
同步是阻塞模式，异步是非阻塞模式
## 6、BIO、NIO
(1) BIO是同步阻塞

(2) BIO是同步非阻塞

## 7、IO多路复用
(1) 概念
理解 ：多个网络连接复用一个io线程
IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程

(2) 三种实现方式
select、poll、epoll

## 8、内存泄露
(1) 引起的原因
申请变量空间后，没有释放，主要出现在需要手动释放空间的语言中（如C语言）

(2) 如何避免
● C++中的 智能指针 / RALL机制（resource acquisition is initialization ：资源获取即初始化）：核心是把资源和对象的生命周期绑定，对象创建获取资源，对象销毁释放资源。在RALL指导下，把资源管理的底层问题提升到了对象生命周期管理的更高层次 。RAII 的主要原则是为将任何堆分配资源（例如，动态分配内存或系统对象句柄）的所有权提供给其析构函数包含用于删除或释放资源的代码以及任何相关清理代码的堆栈分配对象。

(3) 如何查找

(4) 内存泄漏和内存溢出的区别
内存泄漏的本质是“泄漏”，即应该保密的东西（私有的数据）而泄漏给了外界，很常见的原因就是内存没有释放，导致外界通过非正常手段获取到了

内存溢出的本质是“溢出”，满而溢，所以溢的前提是必须满，即必须内存占已经占满，这时再多申请的内存就像是从盛满水的水桶中溢出来那样，故称此现象为“内存溢出”
## 9、系统调用和库函数的区别
系统调用会使操作系统进入内核态，而库函数则一般还是在用户态执行。所以库函数一般只是对系统调用的再次封装，无法越权做系统调用做的事情，如系统信号
## 10、死锁的条件和处理死锁的方法
互斥、不可抢占、占有且等待、循环等待
处理和预防死锁，就是要打破这4个条件

死锁的处理基本策略和常用方法，解决死锁的基本方法如下：
预防死锁、避免死锁、检测死锁、解除死锁
解决四多的常用策略如下：
鸵鸟策略、预防策略、避免策略、检测与解除死锁
## 11、指针和引用的区别和联系
● 指针和引用的值都是地址，一般都是指向某个变量对象
● 指针可以为空，引用不能为空，且指针的指向可以更新，而引用被赋值指向某个变量后，不允许再修改。
● 引用比较类似常量指针
● 引用可以做的事情，指针也可以做，但是指针的权限过大，使用比较危险，所以才会出现“引用”这个概念，引用是权限降低版的指针，更像是“安全版的指针”
● 如果的确只需要借用一下某个对象的"别名"，那么就用"引用"，而不要用"指针"
## 12、值传递、指针传递、引用传递的区别
● 值传递 ：对值的修改不会影响原始值
● 指针传递 ：对值的修改会影响原始值
● 引用传递 ：对值的修改会影响原始值
对于引用类型（对象、资源类型、Slice、Map）看起来是值传递，但其实是引用传递
## 13、Linux命令
(1) 查找整个目录下包含关键词的文件并全局替换文件内容
# 不是这样写的，我只是说需要用 grep 和 sed 组合
grep -ri 'xxx' . | sed -i "s/xxx/aaa/g"
grep命令 & sed 命令
(2) Linux命令格式
Linux 命令格式 ：命令名 [ 选项] [参数1] [参数2]
选项如果是一个横线，则一般是选项的缩写、简写。选项如果是两个横线，则一般是选项的全拼
(3) 说下你常用的Linux命令
这种问题很扯淡，需要你自己从文件命令、系统命令、网络命令、内存命令、磁盘命令等这样的类别中，自己一点一点去说，否则你如果只说是“grep”之类的，面试官会觉得你了解很浅
netstap 、lsof 、awk 、ps 、df -h
## 14、银行家算法
当一个进程申请使用资源的时候，银行家算法通过先 试探 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。

那么此时会有一个问题，如何判断系统是否处于安全状态？算法流程将用下面一张图来表示。


## 15、信号量
waitgroup是Go语言中专门用于做同步等待、协程间同步的操作，其底层原理是信号量
## 16、排查线程、内存、协程数方法
基本思想是对线程或进程之间做堆栈分析

## 17、原子性和事务的区别
原子性 ：原子 -> 不可分割 -> 要么都做要么都不做
事务 ：事务是原子性的父集，原子性只是事务的一个特性而已

## 18、什么是单机QPS
即只用一台服务器，可以支撑的最大QPS。而不是通过多台服务器分摊才可以支撑的最大QPS
## 19、如何保障缓存和数据库一致性
1、采用延时双删处理
先删缓存，再写数据库，休眠一段时间（读数据业务耗时+Redis和数据库主从同步耗时），再删缓存
缺点 ：(1) 休眠时间的估算准确性 (2) 增加了写请求的耗时
## 20、互斥锁和悲观锁的区别
互斥锁 ：如果处于锁状态，读线程和写线程都无法执行，直到获取锁后才停止等待，开始执行
悲观锁 ：如果处于锁状态，允许读但不允许写（读线程可以读，写线程不可以写）
## 21、理解CAP理论
## 22、线程池的原理和简单实现
线程池的线程复用就是通过取Worker 的firstTask 或者通过getTask 方法从workQueue 中不停地取任务，并直接调用Runnable 的run 方法来执行任务，这样就保证了每个线程都始终在一个循环中，反复获取任务，然后执行任务，从而实现了线程的复用。

提前创建N个线程，每个线程都取任务执行。
## 23、为什么要多线程？为什么能多线程？
为什么能多线程 ：CPU分片
## 24、为什么要控制线程数，不能一直创建新线程？
## 25、CAS的实现原理
CAS是一种思想，比较和交换。这种思想可以在硬件层实现（CMPXCHG等CPU指令），也可以在应用层实现（乐观锁）
## 26、操作系统有哪些调度方式


## 27、如何实现按照优先级的抢占式调度
把所有任务放在一个小根堆里，堆顶的自然就是目前的任务队列优先级最高的任务
## 27、类加载过程
## 28、内核态和用户态的区别，为什么要区分用户态和内核态
## 29、创建进程调用的是OS哪些方法
fork() / vfork() / clone()

系统调用fork()和vfork()是无参数的，而clone()则带有参数。fork()是全部复制，vfork()是共享内存，而clone() 是则可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的 clone_flags来决定。另外，clone()返回的是子进程的pid。
## 30、垃圾回收算法具体说说？各种垃圾回收器了解吗？什么时候执行STOP THE WORLD？
## 31、信号量怎么实现对共享资源的访问
## 32、僵尸进程和孤儿进程
子进程退出时，父进程并未对其发出的SIGCHLD信号进行适当处理，导致子进程停留在僵死状态等待其父进程为其收尸，这个状态下的子进程就是僵尸进程。

孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。
## 33、什么是线程饿死，什么是活锁？
## 34、请说出你所知道的线程同步的方法
## 35、为什么需要虚拟内存，简述分页分段机制
内存空间有限，不可能把所有进程都载入内存中，而且内存寻址也会浪费时间

进程间不独立，一个进程可能修改另一个进程数据，导致出错。

虚拟内存，它是一种内存管理技术，能为每个进程提供一个独有的、连续的虚拟地址空间。并通过内存交换技术，把不常用的内存换出到硬盘，需要时再换入内存，从而让有限的内存能运行更大的程序。
## 36、如何判断一个对象是否存活？（或者 GC 对象的判定方法）
GC算法，引用计数、GCROOT
## 37、内存逃逸
## 38、Full GC、Minor GC、Major GC
https://www.zhihu.com/question/41922036
Minor GC和Major GC是俗称，在Hotspot JVM实现的Serial GC, Parallel GC, CMS, G1 GC中大致可以对应到某个Young GC和Old GC算法组合；
## 39、加锁时要考虑什么
考虑什么时候释放锁，是否会出现死锁，是否会影响性能
## 40、LRU和LFU是什么，页面置换算法用的哪一个？
常用的缓存算法包括 ：
● LRU (Least recently used) 最近最少使用，如果数据最近被访问过，那么将来被访问的几率也更高。
● LFU (Least frequently used) 最不经常使用，如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。
● FIFO (Fist in first out) 先进先出， 如果一个数据最先进入缓存中，则应该最早淘汰掉。

所以LFU可以视为一个按访问频率排列的队列，访问最小的先被淘汰掉。而LRU有较复杂的淘汰规则，不只是简单按照访问频率排列。
## 41、如何解决循环依赖
## 42、自旋锁
## 43、有哪些中断
(1) 同步中断和异步中断
同步中断是在指令执行时由CPU主动产生的，受到CPU控制，其执行点是可控的。
(2) 硬中断和软中断
硬中断由硬件产生、软中断由软件（进程）产生
内核与硬件通信的方式：轮询和中断。轮询速度太慢，中断被大量采用。
(3) 中断发生之后
中断发生之后，需要中断处理程序去处理，中断处理程序就是一个函数（类似回调函数）
## 44、虚拟地址和物理地址怎么转换
有了TLB之后，CPU访问某个虚拟内存地址的过程如下 
1.CPU产生一个虚拟地址 
2.MMU从TLB中获取页表，翻译成物理地址 
3.MMU把物理地址发送给L1/L2/L3/内存 
4.L1/L2/L3/内存将地址对应数据返回给CPU 

## 45、两个进程的变量的地址相同，它们之间的写操作有相互的影响吗
## 46、引用计数的循环引用问题
使用GCROOT解决
## 47、段页式管理下，CPU取数据要几次访存
## 48、用户态到内核态切换的条件和过程
当发生 系统调用、中断 时，用户态会切换到内核态
## 49、linux最多可以建立多少个tcp连接，client端，server端，超过了怎么办
## 50、linux启动过程
## 51、进程状态和线程状态有哪些

进程的五态模型 ：新建、就绪、运行、阻塞、终止
线程的五态模型 ：新建、就绪、运行、阻塞、死亡
## 52、TLB缓存
和CPU的L1、L2、L3的缓存思想一致，既然进行地址转换需要的内存IO次数多，且耗时。那么干脆就在CPU里把页表尽可能地cache起来不就行了么，所以就有了TLB(Translation Lookaside Buffer)，专门用于改进虚拟地址到物理地址转换速度的缓存。其访问速度非常快，和寄存器相当，比L1访问还快。
## 53、局部性原理
(1). 时间上的局部性：最近被访问的页在不久的将来还会被访问
(2). 空间上的局部性：内存中被访问的页周围的页也很可能被访问
## 54、颠簸
　颠簸本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。

内存颠簸的解决策略包括：

如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；

如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；

否则，还剩下两个办法：终止该进程或增加物理内存容量。
## 55、分页和分段的区别

## 56、一致性哈希
因此，一致性哈希算法对于节点的增减都只需重定位换空间的一小部分即可，具有较好的容错性和可扩展性
## 57、epoll的LT和ET模式
## 58、struct字节对齐，为什么要进行字节对齐

# 四、工程

## 1、MQ部分

(1) MQ的作用

解耦、异步、削峰

(2) MQ的缺点

系统可用性降低（MQ可能会挂掉）、系统复杂度提高（保证不重复消费、消息丢失的处理）、一致性问题

(3) 如何保证消息不被重复消费

① 消费者通过对消息做MD5加密，判断是否在缓存中已存在

(4) 消息丢失如何处理

① 生产者丢失 ：使用RabbitMQ提供的事务功能（同步耗性能）、Confirm模式（异步效率高）
② MQ丢失 ：开启 RabbitMQ 的持久化
③ 消费者丢失 ：使用MQ提供的Ack机制

(5) 消息积压如何处理

加快消费速度，多开启一些消费程序或消费协程

(6) 如何保证消息的顺序性

需要保证顺序的消息，都发往同一个消费程序，或同一个消费协程
(7) 消息队列的原理，设计，可用性

(8) 解决Kafka拥堵

(9) Kafka事务的使用方法、原理

(10) kafka怎么保证消息不丢失的

(11) Kafka底层是如何保证消息顺序性的

类似消息ID的东西 ？

(12) Kafka都有哪些节点

Broker、Producer、Consumer、Partition、Topic、Consumer Group
## 2、缓存部分

(1) Redis为什么是单线程的
因为Redis是基于内存的操作，CPU不是Redis的瓶颈，IO才是Redis的瓶颈。所以解决IO问题才是最关键的，解决IO问题不需要多线程（使用IO多路复用即可），而且单线程容易实现，避免了线程开销、锁的性能开销等。

(2) Redis为什么单线程效率高
① 不需要各种锁的性能消耗
② 不需要线程切换的开销
③ Redis使用IO多路复用技术
④ Redis是纯内存操作

(3) Redis客户端执行一条命令的过程
分为四个过程：发送命令、命令排队、命令执行、返回结果

(4) 如果CPU是Redis瓶颈、或想提高Redis性能
多开启几个Redis进程

(5) 单线程的优劣势
优势 ：保证了每个操作的原子性
劣势 ：无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善

(6) redis 的线程模型
redis内部使用文件事件处理器file event handler，这个文件事件处理器是单线程的，所以redis才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。

文件事件处理器的结构包含4个部分
● 多个 socket
● IO 多路复用程序
● 文件事件分派器
● 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

(7) 缓存穿透
把存在的数据存储在布隆过滤器中，使用布隆过滤器判断key是否存在，不存在的话，直接返回，不查询DB

(8) 缓存雪崩
定义随机失效时间，不要把失效时间统一在某个时间点，失效时间要尽量分散

(9) Redis为什么采用跳表而不是红黑树

(10) 实现延迟队列
使用Redis Zset实现

(11) Pipeline的命令数量取决于哪些因素
客户端发送缓冲区大小、服务端缓冲区大小、网络带宽、排队等待的最大可接受时延（即最慢多久执行完成）

(12) Redis线程模型
在传统的Redis中线程模型是单线程的，但是在阿里云开发的Redis或各种Redis版本中，是可以支持多线程的，如下图为阿里云的Redis

(13) Redis命令是原子性的吗
答 ：对于使用方来说大部分命令是原子性，但pipeline并不是原子性的。而且Redis大部分命令内部实现并不是原子性的

(14) Redis有哪些性能优化方案
1、Master不要做持久化工作（如RDB、AOF等），而使用Slave从库做持久化工作
2、为了主从复制的速度和稳定性，Master和Slave最好在同一个机房/局域网内
3、主从复制不要使用网状/图状结构，用单向链表结构更为稳定，即Master <- Slave1 <- Slave2 <- Slave3。这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂掉，可以立即使用Slave1做Master

(16) Redis的事务实现原理，为什么不支持回滚
Redis的作者在事务功能的文档中解释说，不支持事务回滚是因为这种复杂的功能和Redis追求的简单高效的设计主旨不符合，并且他认为，Redis事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为Redis开发事务回滚功能。所以我们在讨论Redis事务回滚的时候，一定要区分命令发生错误的时候。
在Redis中实现事务主要依靠以下几个命令来实现：

1.事务开始
Redis将执行该命令的客户端从非事务状态切换成事务状态，这一切换是通过在客户端状态的flags属性中打开REDIS_MULTI标识完成

2.命令入队
在客户端打开了事务标识后，只有命令：EXEC，DISCARD，WATCH，MULTI命令会被立即执行，其它命令服务器不会立即执行，而是将这些命令放入到一个事务队列里面，然后向客户端返回一个QUEUED回复 

3.事务执行
Redis不支持事务的回滚机制，即使事务队列中的某个命令在执行期间出现错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止

(17) 使用Redis防止用户重复下单
使用Redis分布式锁的方式，防止用户重复下单

(18) 秒杀/减库存/防止超卖
使用Redis+Lua的方式实现减库存

(19) Redis的多线程和单线程的瓶颈
Redis 6.0之后引入多线程

(20) Redis过期策略
● 定时删除
● 定期删除
● 惰性删除
● 内存替换（如LRU算法）
如果定时删除、定期删除、惰性删除都有漏掉的Key时，Redis还提供了内存替换机制，类似LUR算法，当内存超过一定值后，使用LRU算法，把过期的Key删除掉
(21) redis最多能存多少数据
redis最多能支持2^32个键，差不多就是2.5亿个，每个key中的值也是可以存 2^32行数据

(22) ZSet是如何实现的，画出数据结构
ziplist 和 skiplist ，具体使用哪个类型，是由当前Key中的元素数量决定的
skiplist 底层是由跳表实现的

(23) zrange start, stop, 总长度为 n, 复杂度是多少?
Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements returned.
其中 N 是排序集中的元素数，M 是返回的元素数。
之所以是O(log(N)+M)，是因为底层跳表存储结构的原因。

log(N) 查找star的时间复杂度
M ：拉出遍历从start到stop一共N个元素的时间复杂度

跳表中的元素最下面的一层是有序的(上面的几层就是跳表的索引)，按照分数排序，我们只要找出 start 代表的元素，然后向前或者向后遍历 M 次拉出所有数据即可，而找出 start 代表的元素，其实就是在跳表中找一个元素的时间复杂度。跳表中每个节点每一层都会保存到下一个节点的跨度，在寻找过程中可以根据跨度和来求当前的排名，所以查找过程是 O(log(N) 过程，加上遍历 M 个元素，就是 O(log(N)+M)，所以 redis 的 zrange 不会像 mysql 的 offset 有比较严重的性能问题。

(24) redis管道原理？保证原子性吗

(25) 管道和事务的区别？redis事务保证原子性么
pipeline是客户端的行为，对于服务器来说是透明的，可以认为服务器无法区分客户端发送来的查询命令是以普通命令的形式还是以pipeline的形式发送到服务器的；

而事务则是实现在服务器端的行为，用户执行MULTI命令时，服务器会将对应这个用户的客户端对象设置为一个特殊的状态，在这个状态下后续用户执行的查询命令不会被真的执行，而是被服务器缓存起来，直到用户执行EXEC命令为止，服务器会将这个用户对应的客户端对象中缓存的命令按照提交的顺序依次执行。

(26) Redis集群一致性问题
一致性分为 ：强一致性、弱一致性、最终一致性

但是redis集群无法保证强一致性，因为主从复制需要时间

Redis用最终一致性换取了高吞吐量

主节点挂了的时候，如果数据没有同步到备节点，是会出现数据丢失的情况

(27) 怎么统计一亿用户的日活，hyperloglog有什么缺点，bitmap不行么

(28) 分布式锁
分布式锁使用setnx实现，通过给锁加过期时间，实现锁的自动释放。

(29) HASH扩容
redis中的hash表采用的是渐进式hash的方式。ht 属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下使用的都是ht[0]的哈希表，而ht[1]的哈希表只会在rehash的时候使用。

渐进式rehash采用的是一种分而治之的方式，将rehash的操作分摊在每一个的访问中，避免集中式rehash而带来的庞大计算量。

在扩容和收缩的时候，如果哈希字典中有很多元素，一次性将这些键全部rehash到ht[1]的话，可能会导致服务器在一段时间内停止服务。所以，采用渐进式rehash的方式，详细步骤如下


1、redis字典（hash表）底层有两个数组，还有一个rehashidx用来控制rehash
将 rehashindex 的值设置为 0 ，表示rehash工作正式开始（只要rehashidx不是-1就表示处于rehash状态）

2、初始默认hash长度为4，当元素个数与hash表长度一致时，就发生扩容，hash长度变为原来的二倍
3、redis中的hash则是执行的单步rehash的过程
在渐进式rehash的过程，如果有增删改查操作时，如果index大于rehashindex，访问ht[0]，否则访问ht[1]。

随着操作的进行，哈希表中的键值对会逐渐增多或减少，这时为了让哈希表负载因子位置在一个合理的范围之内就会对哈希表大小进行扩展或收缩即rehash。

(30) 什么时候需要布隆过滤器，以及它的原理


(31) lazy free 机制

(32) 重要服务器参数
lazyfree-user-del ：用户手动执行del命令时的延迟释放策略（如del 命令）
lazyfree-server-del ：服务器自动删除数据时的延迟释放策略（如Key过期）

在Redis服务器参数配置中经常可以看到 eviction 这个单词，这个单词表示的意思逐出，其实就是 “内存淘汰” 。Redis内存淘汰可以使用类似LRU这样的内存淘汰算法，当内存中存储数据超过最大值时，把不需要的过期数据淘汰掉。


(33) Redis QPS问题
普通单机版
短连接 ：3w左右QPS
长连接 ：10W左右QPS

集群版 / 性能增强版
短连接 ：10w左右QPS
长连接 ：15W左右甚至更多

(34) AOF机制

(35) Redis慢日志

(36) Redis集群原理

(37) Redis Set实现原理

set内部使用到了intset(整数集合)和hashtable(哈希表)两种方式来存储元素，如果set存储的元素是整数，且当元素个数小于512个会选择intset存储，目的是减少内存空间，遇到两种情况会发生变化，就是当存储的元素个数达到512(通过set-max-intset-entries 配置)或者添加了非整数值时如：‘b’，set会选择hashtable作为存储结构。

整数集合intset是用来存储整数的集合，且存储是按照小到大的顺序来存储(可以二分查找)，intset目的是用来节省内存，当Redis集合类型的元素都是整数并且都处在64位有符号整数范围之内时，使用该结构体存储,
typedef struct intset{
    //编码类型
    uint32_t encoding;
    //集合元素数量
    uint32_t length;
    //存储元素的数组
    int8_t contents[];
} intset;
(38) Redis 导出RDB过程中 ，如果有新增的命令 是怎么处理的 ？
Redis还有一个AOF机制，可以生成新增的命令

## 3、数据库部分

(1) 联合索引
(2) 乐观锁和悲观锁
获取数据的时候加锁获取 select * from table_xxx where id='xxx' for update; 注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的 悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用

乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。 

乐观锁的实现方式多种多样可以通过version或者其他状态条件： 

1. 通过版本号实现 
update table_xxx set name=#name#,version=version+1 where version=#version# 
(3) 如果多个管理员同时修改博客，用乐观锁悲观锁如何解决 ？

(4) 写一个SQL查出每班成绩前三的同学 student(no, name, classId, grade)

(5) 怎么解决慢查询

(6) mysql的锁机制，有事务为什么还用锁

因为有些场景用事务可能解决不了，所以还是需要手动用锁，才能保证数据一致性。

共享锁与排他锁 ：
● 共享锁（读锁）：其他事务可以读，但不能写。
● 排他锁（写锁） ：其他事务不能读取，也不能写。

粒度锁 ：
行级锁和表级锁。默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。


(7) mysql字段默认值为什么不能设置为null
● 可能会出现不确定的查询，导致无法使用索引，引起数据库查询效率低下
● 如果很多字段可以为空，之后如果需要优化索引，则会引起不必要麻烦

(8) mysql索引底层实现
B+树
(9) 访问数据库，从数据库连接池到数据库返回结果的过程
https://www.zhihu.com/question/53589525/answer/275249556
利用JDBC driver和MySQL数据库建立TCP连接之后的连接对象放在池中，当需要操作数据库的时候从池中取出一个连接，发送SQL到MySQL，MySQL经过SQL语法解析、查询优化、生成实际物理计划及执行、连接处理与类型处理等一系列的过程之后返回要查询的数据给JDBC driver的resultset。把连接对象重新放到池子中。

(10) 数据库连接池和线程池的好处
提升性能 和 方便管理 
这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程

(11) 如何处理长时间等待执行的SQL
如果已经有长时间等待的sql执行中，在MySQL命令行中输入如下命令直接杀掉
show processlist; 
kill $pid;

(12) 怎么查看数据库内存占用情况
# 在Linux命令行执行
top

# 在MySQL命令行执行
show processlist

# 查看performance_schema数据库，使用命令查看和内存相关的表
show tables like '%memory%';

(13) 减少回表
尽量避免使用select *进行查询。因为select *不能运用到覆盖索引，必然会导致mysql回表二次查询，效率低下，如果select和where的内容只有索引列，可以提升mysql查询效率，数据量很大的表更明显。

(14) 执行计划原理和作用

(15) 什么情况下会引起全表查询

(16) 如何理解数据库事务中的一致性
https://www.zhihu.com/question/31346392/answer/362597203

这里的一致性是指系统从一个正确的状态，迁移到另一个正确的状态。而事务具备ACID里C的特性是说通过事务的AID来保证我们的一致性。

ACID里的AID都是数据库的特征，也就是依赖数据库的具体实现。而唯独这个C，实际上它依赖于应用层。也就是依赖于开发者。

做个比喻事务就好比一个保镖,我们提到事务就会说ACID,而我们提到保镖会说强壮,保护安全,好功夫,踏实.这里强壮,好功夫和踏实都是保镖自己的特征,而安全是属于你的,而你通过保镖的特征来保护你的安全.

所以综上，你可以理解一致性就是：应用系统从一个正确的状态到另一个正确的状态。而ACID就是说事务能够通过AID来保证这个C的过程。C是目的，AID都是手段

(17) 四种隔离级别
Read Uncommitted ：所有并发问题都有
Read Committed ：解决脏读
Repeated Read ：解决不可重复读
Serialization ：解决幻读

(18) MVCC
https://zhuanlan.zhihu.com/p/231947511
https://juejin.cn/post/6844903778026536968#heading-5

MVCC是一种解决读写冲突的无锁并发控制。

主要是为了解决数据库的三种并发场景 ：1、读读 2、读写 3、写写

MVCC的实现原理主要依赖于记录中的三个隐藏字段，undolog，read view来实现


MVCC是指多版本并发控制。MVCC是在并发访问数据库时，通过对数据进行多版本控制，避免因写锁而导致读操作的堵塞，从而很好的优化并发堵塞问题。

通过对并发数据进行快照备份，从而达到无锁数据的并发访问。
通俗的讲就是MVCC通过对数据进行多版本保存，根据比较版本号来控制数据是否展示，从而达到读取数据时无需加锁就可以实现事务的隔离性。

MVCC的两个实现核心是undo log和一致性视图，通过undo log来保存多版本的数据，通过一致性视图来保存当前活跃的事务列表，将两者结合和制定一定的规则来判断当前可读数据。

(19) Mysql保存在磁盘中的数据格式是什么，又如何编译成我们能识别的格式

(20) MySQL索引再内存中以什么格式保存

(21) B+树是一个怎样的树状？为什么会这样
是一个又矮又胖的树状，这样可以减少磁盘IO

(23) MySQL的分库分表，垂直分表和水平分表的选择
垂直分表和水平分表的选择

(24) 你是如何去优化慢SQL的
对慢SQL优化一般可以按下面几步的思路：
1、开启慢查询日志，设置超过几秒为慢SQL，抓取慢SQL
2、通过explain对慢SQL分析（重点）
3、show profile查询SQL在Mysql服务器里的执行细节和生命周期情况（重点）
4、对数据库服务器的参数调优


(25) 一条SQL的执行过程

(26) 什么是最左匹配原则，为什么需要

(27) B+树和二叉树有什么区别和优劣，为什么索引用B+树? B+树的时间复杂度？
B+树一般不超过4层

(28) MySQL 的存储引擎用的是什么?为什么选 InnoDB?
https://www.zhihu.com/question/20596402

InnoDB支持事务 ，Myisam不支持事务，这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；

4. InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；

5、InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

(29) MySQL 的聚簇索引和非聚簇索引有什么区别？

(30) 假如要查 A in () AND B in (), 怎么建索引？

(31) 查 A in () AND B in () 时, MySQL 是怎么利用索引的？

(32) 假如查询 A in (), MySQL 是针对 N 个值分别查一次索引, 还是有更好的操作？

(33) 分库分表后怎么查询分页


(34) 分库分表后怎么保证主键仍然是递增的

(35) 假如量很大, 你觉得需要分库分表吗? 怎么分?

(36) 假如用 id 翻页的方式, 数据库表如何设计? 索引如何设计?

(37) 什么是幻读

(38) InnoDB如何防止幻读

(39) mysql union index 原理

(40) 联合索引的存储结构是什么，它的有效方式

(41) 如何评估一个索引建的是否合理

(42) 索引越多越好吗？
索引越多，底层的维护成本也越多，而且数据库底层选择索引的时候，可能会不符合预期

(43) 影响INNODB的性能和指标的元素可能有哪些

(44) LIKE操作什么时候走索引
在正常情况下，百分号在后面，可以使用索引：
select object_name from t1 where object_name like ‘DBA%';

百分号在前面，不能使用索引：
select object_name from t1 where object_name like '%LIB';

(45) 全文索引


(46) 原子性和一致性的实现原理

(47) 建表会定义自增id么，为什么，自增id用完了怎么办

(48) 一般你们怎么建mysql索引，基于什么原则，遇到过索引失效的情况么，怎么优化的

(49) 为什么需要最左前缀匹配

https://www.cnblogs.com/xuwc/p/14007766.html
(50) 做过分库分表么，为什么要分库分表，会有什么问题

(51) 多少数据适合分库分表，跨库，聚合操作怎么做

(52) 聚族索引和非聚族索引
聚族索引 ：数据和索引再一个文件中，如 innodb 引擎中的 .idb 文件
非聚族索引 ：数据和索引不在一个文件中，如 myisam 引擎中的 .myd文件（存数据） 和 .myi文件（存索引）

.frm 文件是数据库引擎中定义的表结构文件

需要补充的是，在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。

(53) Binlog的三种类型
row 、statement 、mixed

(54) 数据库瓶颈
不管是IO瓶颈，还是CPU瓶颈，最终都会导致数据库的活跃连接数增加，进而逼近甚至达到数据库可承载活跃连接数的阈值。在业务Service来看就是，可用数据库连接少甚至无连接可用。接下来就可以想象了吧（并发量、吞吐量、崩溃）。
1、IO瓶颈
第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -> 分库和垂直分表。
第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 -> 分库。
2、CPU瓶颈
第一种：SQL问题，如SQL中包含join，group by，order by，非索引字段条件查询等，增加CPU运算的操作 -> SQL优化，建立合适的索引，在业务Service层进行业务计算。
第二种：单表数据量太大，查询时扫描的行太多，SQL效率低，CPU率先出现瓶颈 -> 水平分表。

(55) 索引列长度

(56) 索引分类

(57) InnoDB间隙锁

(58) 查询成本

(59) 死锁分析

(60) MySQL两阶段提交

(61) or 查询的问题
OR查询可能会引起慢查询，解决方案可以用 Union 查询（实测发现Union也不行），或者是分两次查询把数据合在一起

explain select * from intimacy_score where useridsmall = 23243 and status = 1 union select * from intimacy_score where useridbig = 23243 and status = 1 order by id desc limit 100;

(62) AND 查询的问题

(63) InNoDB引擎可能会遇到的锁有哪些 
行锁、间隙锁、表锁（基本不常见）

(64) 快照读和当前读

(65) InnoDB引擎和Myisam引擎的区别
InnoDB的成功也正是充分利用了MVCC读不加锁的并发能力。

## 4、Nginx部分

(1) Nginx如何处理请求的
Master进程和Worker进程

(2) Nginx的IO模型

## 5设计模式

(1) 装饰者模式

(2) 手写单例模式

(3) 重载和重写的区别

(4) 实现线程安全的单例模式

## 6、秒杀抢购部分

(1) 1台服务器怎么做抢购

## 7、用户验证
(1) 单点登录，多服务器如何保证数据一致性
公共服务器用做登陆服务

(2) 分布式 Session 共享解决方案

## 8、限流算法与应用
(1) 限流算法
限流算法一般有漏桶算法和令牌桶算法两种限流算法 ，详见这里

(2) 限流应用
1) 抢购
TairString是Redis企业版性能增强型实例集成了阿里巴巴Tair后新增的数据结构，比原生Redis String功能更加强大，除了比特位（bit）操作外能够覆盖原生Redis String的所有功能。

TairString的EXINCRBY/EXINCRBYFLOAT命令与原生Redis String的INCRBY/INCRBYFLOAT命令功能类似，都可对value进行递增或递减运算，但EXINCRBY/EXINCRBYFLOAT支持更多选项，例如EX、NX、VER、MIN、MAX等，详细说明请参见TairString命令。下文介绍的方案涉及MIN与MAX两个选项：

使用原生Redis String实现抢购，代码逻辑复杂，一旦管理不当，容易出现漏网订单，即明明商品已经抢完，却还有用户收到抢购成功的提示，造成不良影响，而使用TairString，只需要非常简单的代码即可实现严谨的订单数量限制
if(EXINCRBY(key_iphone, -1, MIN:0) == "would overflow")
    run_out();
    
2) 限流计数器
与抢购限流器类似，使用EXINCRBY命令的MAX选项可以实现限流计数器，伪代码如下：
if(EXINCRBY(rate_limitor, 1, MAX:1000) == "would overflow")
    traffic_control();
限流计数器的应用场景很多，例如并发限流、访问频率限制、密码修改次数限制等等。以并发限流为例，在请求的并发量突然超过系统的性能限制时，为了防止服务彻底崩溃引发更大的问题，采用限速器限制并发量，保证系统处理能力内的请求得到及时回应，是一种较合理的临时解决方案。使用TairStringEXINCRBY命令，您可以通过简单的代码设置一个并发限流器：
public boolean tryAcquire(Jedis jedis,String rateLimitor,int limiter){
    try {
        jedis.getClient().sendCommand(TairCommand.EXINCRBY,rateLimitor,"1","EX","1","MAX",String.valueOf(limiter)); // 设置限流器
        jedis.getClient().getIntegerReply();
        return true;
    }catch (Exception e){
        if(e.getMessage().contains("increment or decrement would overflow")){ // 检查返回结果中是否包含错误信息
            return false;
        }
        throw e;
    }
}
## 9、接口幂等
(1) 实现方法
● 把参数统一存入缓存，如果在某段时间内有相同参数的请求，则判定为重复提交
● 使用唯一索引unique key实现
(2) 如果用redis用什么数据结构存？
setnx 、hsetnx

## 10、ES
(1) 为什么重建索引
修改mapping字段、索引性能出现问题、索引的分片出现问题、索引占用内存出现问题

(2) 分片不均

(3) 倒排索引的原理
lucene，分词，分片，副本
(4) ES性能调优问题

11、唯一自增ID的生成
id要是稀疏的，64位

12、加密算法

13、多线程编程

(1) 多线程编程要考虑什么
(2) 线程上下文切换的开销具体是什么
14、微信红包
(1) 微信红包，我是在一开始拆分，还是在用户抢红包的时候拆分？
(2) 微信红包退款如何保证正确

# 五、算法

1、无序链表如何查找中位数
中位数：中间的那个数
遍历链表生成一个数组，对数组排序，然后直接找到中间那个数

2、写一个二分查找
<?php

function binsearch($x,$a){
    $c=count($a);
    $lower=0;
    $high=$c-1;
    while($lower<=$high){
        $middle=intval(($lower+$high)/2);
        if($a[$middle]>$x){
            $high=$middle-1;
        } elseif($a[$middle]<$x){
            $lower=$middle+1;
        } else{
            return $middle;
        }
    }
    return -1;
}

3、冒泡排序思想

4、堆排序的思想、建堆的过程
堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：
1. 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
2. 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；
堆排序的平均时间复杂度为 Ο(nlogn)。

5、快速排序思想

6、斐波那契数列

7、有一套ip段和城市的对应关系数据，需要一个函数，给出ip，返回相应城市

8、哈希表
(1) 负载因子概念和作用

9、把两个数组合并并且排序

10、链表1 2 3 5 4 6 7把奇数排前面

11、二叉树的前序/后序遍历非递归

12、求数组的最长连续递增数列
如：4， 200， 3， 1， 100， 2。结果是1 2 3 4，也就是说顺序可以打乱
面试官给的思路是用一个hashtable，hash到4的时候，看看hash（3）和hash（5）是否存在，类似这样的思路

13、求二叉树的最大路径和

14、一个二维矩阵，从左到右是升序，从上到下是降序，找一个数是否存在于矩阵中
类似于二叉查找树

15、不用循环求X的Y次方
递归 ？

16、如果手上只有一个随机生成1~9的随机数生成器 Random9，如何得到随机生成1~7的随机数生成器1-7？
解法一 ：直接random9()生成，如果是大于7的数据则重新生成，否则返回
解法二 ：通过 random9() 可以得到如下随机生成器
1. Random9() - 1 --- 得到了随机生成 0~8的发生器
2. (Random9() - 1) / 8 --- 得到了生成 0~1 的标准随机数生成器
3. 想要得到 1~7 是不是很简单了呢？ --- ((random9() - 1) / 8 * 6) + 1

17、常用排序算法对比

18、合并K个排序数组
将 k 个有序数组合并为一个大的有序数组。

19、合并K个升序链表
https://leetcode-cn.com/problems/merge-k-sorted-lists/

20、500个数组，每个数组500个元素，每个数组从大到小拍好了序，求这500个数组中前500大的数

21、求一个环形链表的环的长度

# 六、数据结构

1、双端队列
两边都是可以进出的队列

2、图和树的区别
(1) 结构组成不同，图会形成环，树不会形成环。图有边，且边一般具有权重
(2) 使用上的不同，图的数据结构操作和树的结构操作肯定不同
(3) 关系不同，图中每个节点的关系是平等的，而树中不同的节点有父子关系
(4) 解决问题不同，树主要是解决子任务、子问题。图主要是解决关系、距离类的问题

3、常用的数据结构
字符串、链表、散列表/哈希表、数组、栈、队列、堆、树、图

4、无锁队列
队列的基本使用（出队和入队）不需要加锁也是线程安全的。实现原理是基于CAS

5、跳表
跳表的时间复杂度O(logn)
跳跃列表的平均查找和插入时间复杂度都是O(logn)


